#!/usr/bin/python3

import pickle
import argparse
import pyjq
import json
import os
import re
import sys
import time
import yaml
import googleapiclient.discovery
from apiclient import errors
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request

import pprint
SCOPES = ['https://www.googleapis.com/auth/admin.directory.user',
          'https://www.googleapis.com/auth/admin.directory.group',
          'https://www.googleapis.com/auth/admin.directory.members']

CUSTOMER_ID = "C04bow9da"
DOMAIN = "pennbrain.upenn.edu"
MAXRESULTS = 2
CmdName = os.path.basename(sys.argv[0])

MinServiceGid = 1100
MaxServiceGid = 2000
MinCollectiveGid = 2100
MaxCollectiveGid = 3000
MinUserGid = 3001

debug=False

def get_credentials():

    creds = None
    # The file token.pickle stores the user's access and refresh tokens, and is
    # created automatically when the authorization flow completes for the first
    # time.
    if os.path.exists('token.pickle'):
        with open('token.pickle', 'rb') as token:
            creds = pickle.load(token)
    # If there are no (valid) credentials available, let the user log in.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                '/home/holder/.config/gcloud/credentials.json', SCOPES)
            creds = flow.run_local_server(port=0)
        # Save the credentials for the next run
        with open('token.pickle', 'wb') as token:
            pickle.dump(creds, token)

    return creds


def get_directory_service():

    creds = get_credentials()
    service = googleapiclient.discovery.build('admin', 'directory_v1', credentials=creds)

    return service

# gs<function> interact with g-suite/cloud-identity
# <function> do stuff with existing objects/variables

def getGroupGid(Group):
    description = ""

    if ('description' in Group.keys()):
        description = Group['description']

    m = re.search(r'^.*\{\s*gid:\s+(?P<gid>\d+)\s*\}', description)
    if (m):
        gid = m.group('gid')
    else:
        gid = ""

    return(gid)

def getGroupMembers(service, Group, expand=False):
    Members = []

    if ('members' in Group.keys()):
        for m in Group['members']:
            if (m['type'] == "GROUP"):
                Members += list(map(lambda x: x['email'], gsGetGroupMembers(service, groupKey=m['email'])))
            else:
                Members += [ m['email'] ]

    return(','.join(sorted(set(Members))))

def gsGetGroupMembers(service, groupKey=None, expand=False):
    Members = []
    page_token = None

    while True:
        try:
            results = service.members().list(groupKey=groupKey, pageToken=page_token).execute()
            
            members = results.get('members')
            if (members):
                for m in members:
                    if (m['type'] == "GROUP"):
                        ExpandedMembers = gsGetGroupMembers(service, groupKey=m['email'], expand=True)
                        Members += ExpandedMembers
                    else:
                        Members.append(m)

            page_token = results.get('nextPageToken')
            if (not page_token):
                break

        except errors.HttpError as error:
            print('An error occurred: %s' % (error))
            break

    return(Members)

def gsGetMembersGroups(service, User):
    results = client.groups().list(userKey=user,pageToken=None).execute()

def gsGroupGet(service, groupKey=None):

    Groups = []
    page_token = None
    while True:
        try:
            if (groupKey):
                results = service.groups().get(groupKey=groupKey).execute()
                Groups += [ results ]
            else:
                results = service.groups().list(maxResults=MAXRESULTS, domain=DOMAIN, pageToken=page_token).execute()
                Groups += results.get('groups')

            page_token = results.get('nextPageToken')
            if (not page_token):
                break

        except errors.HttpError as error:
            print('{} : gsGroupGet An error occurred: %s'.format(CmdName, error), file=sys.stderr)
            break

    return(Groups)

def ensureDomain(name):
    if (re.search('@', name)):
        n = name
    else:
        n = name + '@{}'.format(DOMAIN)

    return(n)
    
def gsAddUsersToGroup(service, groupKey=None, Users=None):

    if (groupKey and Users):
        for user in Users:
            results = service.members().insert(groupKey=groupKey, body={ "email": user }).execute()

def gsDeleteUsersFromGroup(service, groupKey=None, Users=None):

    if (groupKey and Users): 
        for user in Users:
            results = service.members().delete(groupKey=groupKey, memberKey=user).execute()

def gsGetGroupGids(service):

    Groups = []
    page_token = None
    while True:
        try:
            results = service.groups().list(maxResults=2, domain="pennbrain.upenn.edu", pageToken=page_token).execute()
            groups = results.get('groups')
            for g in groups:
                Groups.append(g)

            page_token = results.get('nextPageToken')
            if (not page_token):
                break

        except errors.HttpError as error:
            print('An error occurred: %s' % (error))
            break

    Gids = json.dumps(pyjq.all('.[].description | sub("^.*(?<gid>{gid: [0-9]+}).*$"; "\(.gid)") | sub("gid"; "gid") ', Groups), indent=2)
    Gids = json.loads(re.sub('gid:', '"gid":', re.sub('"', '', Gids)))

    return(sorted(pyjq.all('.[].gid', Gids)))

def isCollectiveGid(gid):
    return(gid >= MinCollectiveGid and gid <= MaxCollectiveGid)

def isServiceGid(gid):
    return(gid >= MinServiceGid and gid <= MaxServiceGid)

def isUserGid(gid):
    return(gid >= MinUserGid)

#
# gs-groupadd [-d description][-g gid][-c|s|U][-u user1[[,user2]...] group [group...]
#
def GroupAdd():
    parser = argparse.ArgumentParser(description='Create GS groups')
    parser.add_argument('-g', '--gid', type=int, help='posix group id. Defaults to next available id')
    parser.add_argument('-u', '--users', type=str, help='comma separated list of existing users to add to group(s)')
    parser.add_argument('groups', nargs='+', help='groups to get, if none specified, get all groups')

    setop = parser.add_mutually_exclusive_group()
    setop.add_argument('-c', '--collective', action='store_true', help='collective group')
    setop.add_argument('-s', '--service', action='store_true', help='service group for programs/applications')
    setop.add_argument('-U', '--User', action='store_true', help='user default group')
    args = parser.parse_args()

    service = get_directory_service()

    Users = []
    if (args.users):
        Users = list(map(ensureDomain, sorted(args.users.split(','))))

    t = '-c'
    NewGid = None
    for group in args.groups:
        if (args.gid):
            if (NewGid):
                NewGid += 1
            else:
                NewGid = args.gid

            if (isCollectiveGid(NewGid)):
                t = '-c'
            elif(isServiceGid(NewGid)):
                t = '-s'
            elif(isUserGid(NewGid)):
                t = '-U'
            else:
                print("{} : Invalid Gid '{}'".format(CmdName, NewGid), file=sys.stderr)
                sys.exit(1)

        else:
            Gids = gsGetGroupGids(service)

            if (args.collective):
                t = '-c'
                Gid = list(filter(isCollectiveGid, Gids))
                if (not Gid):
                    Gid = [ MaxCollectiveGid ]

                NewGid = Gid[0] - 1
            elif (args.service):
                t = '-s'
                Gid = list(filter(isServiceGid, Gids))
                if (not Gid):
                    Gid = [ MinServiceGid ]

                NewGid = Gid[0] + 1
            elif (args.User):
                t = '-U'
                Gid = list(filter(isUserGid, Gids))
                if (not Gid):
                    Gid = [ MinUserGid ]

                NewGid = Gid[-1] + 1
            else:
                t = '-c'
                Gid = list(filter(isCollectiveGid, Gids))
                if (not Gid):
                    Gid = [ MaxCollectiveGid ]

                NewGid = Gid[0] - 1

        g = ensureDomain(group)
        # Create the group.  Creation may fail, group may already exist
        # check gid to ensure no repeats
        # 
        # Add the users.  Users might not all exist
        if (debug):
            print("gsGroupAdd {} -gid {} -u {} {}".format(t,NewGid,','.join(Users), g))
        if (gsCreateGroup(service, g, gid=NewGid) and Users):
                gsAddUsersToGroup(service,groupKey=g, Users=Users)

def gsCreateGroup(service, group, gid=None):
    try:
        results = service.groups().insert(body={ 'name': group, 'email': group, 'description': '{gid: %d}' % (gid)}).execute()
        return(True)
    except errors.HttpError as error:
        print('{}: creating group {} : An error occurred: {}'.format(CmdName, group, error), file=sys.stderr)
        return(False)

def gsDeleteGroup(service, groupKey=None):
    try:
        results = service.groups().delete(groupKey=groupKey).execute()
        return(True)
    except errors.HttpError as error:
        print('{}: creating group {} : An error occurred: {}'.format(CmdName, group, error), file=sys.stderr)
        return(False)

def gsUpdateGroup(service, groupKey=None, body=None):
    try:
        results = service.groups().update(groupKey=groupKey, body=body).execute()
        return(True)
    except errors.HttpError as error:
        print('{}: updating group {} : An error occurred: {}'.format(CmdName, group, error), file=sys.stderr)
        return(False)
    
#
# gs-groupdel group1 [[group2]...]
#
def GroupDel():
    parser = argparse.ArgumentParser(description='Delete GS groups')

    parser.add_argument('groups', nargs='+', help='groups to delete')

    args = parser.parse_args()

    service = get_directory_service()

    for group in args.groups:
        g = ensureDomain(group)
        # Delete the group.  Group may not exist.  Deletion may fail
        gsDeleteGroup(service, groupKey=g)


#
# gs-groupmod [-d description][-g gid][-n name][[-a|r|s] -u user1[[,user2]...] group1 [[group2]...]
#
def GroupMod():
    parser = argparse.ArgumentParser(description='Modify GS groups')
    parser.add_argument('-d', '--description', type=str, help='new description.  Gid will be inserted, if not supplied')
    parser.add_argument('-g', '--gid', type=int, help='posix group id. Defaults to next available id')
    parser.add_argument('-n', '--name', type=str, help='new group name')
    
    parser.add_argument('-u', '--userlist', type=str, help='comma separated list of existing users to add to group(s)')
    parser.add_argument('groups', nargs='+', help='groups to add specified users to')

    setop = parser.add_mutually_exclusive_group()
    setop.add_argument('-a', '--append', action='store_true', help='append users')
    setop.add_argument('-r', '--remove', action='store_true', help='remove users')
    setop.add_argument('-s', '--set', action='store_true', help='set users')

    args = parser.parse_args()

    service = get_directory_service()

    UserList = []

    if(args.userlist):
        UserList = set(map(ensureDomain,re.split(',',args.userlist)))

    for group in args.groups:
        g = ensureDomain(group)
        # Create the group.  Creation may fail
        # Add the users.  Users might not all exist
        Group = gsGroupGet(service, g)
        print("g = ",g)
        if (Group):
            Group=Group[0]
        else:
            next

        GroupBody = { 
            'email': Group['email'], 
            'description': stripGidFromDescription(Group['description']), 
            'name': Group['name'], 
            'gid': getGroupGid(Group)
        }

        UpdateGroup = False

        if (args.description):
            GroupBody['description'] = args.description
            UpdateGroup = True

        # *** should make sure the gid isn't already in use...
        if (args.gid):
            GroupBody['gid'] = args.gid
            UpdateGroup = True

        if (args.name):
            GroupBody['name'] = args.name
            UpdateGroup = True

        print("GroupBody = ", GroupBody)

        if (UpdateGroup):
            GroupBody['description'] = insertGidInDescription(GroupBody['description'], GroupBody['gid'])
            gsUpdateGroup(service, groupKey=g, body=GroupBody)

        if (UserList):
            if (debug):
                print("gsGetGroupMembers = ", set(sorted(list(map(lambda x: x['email'], gsGetGroupMembers(service, groupKey=g, expand=False))))))

            DeleteMembers = []
            AddMembers = []

            CurrentMembers = set(sorted(list(map(lambda x: x['email'], gsGetGroupMembers(service, groupKey=g, expand=False)))))

            if (args.append):
                AddMembers = UserList - CurrentMembers

            elif (args.remove):
                DeleteMembers = CurrentMembers & UserList

            elif (args.set):
                AddMembers = UserList - CurrentMembers
                DeleteMembers = CurrentMembers - UserList - AddMembers

            if (debug):
                print("Delete Members", DeleteMembers)
                print("Add Members", AddMembers)

            if (DeleteMembers):
                gsDeleteUsersFromGroup(service, groupKey=g, Users=DeleteMembers)

            if (AddMembers):
                gsAddUsersToGroup(service, groupKey=g, Users=AddMembers)


#        print("gsGroupAdd -u {} {}".format(','.join(UpdateUsers), g))

#
# gs-groupget [-e|j][-u][-c][[group1]...]
#
def groupGet():
    parser = argparse.ArgumentParser(description='List GS groups')

    group = parser.add_mutually_exclusive_group()
    group.add_argument('-j', '--json', action='store_true', help='print json')
    group.add_argument('-e', '--etc', action='store_true', help='print /etc/group format')
    group.add_argument('-c', '--cloud-config', action='store_true', help='print /etc/group format')
    parser.add_argument('groups', nargs='*', help='groups to get, if none specified, get all groups')

    args = parser.parse_args()

    service = get_directory_service()

    Groups = []

    if (args.groups):
        for g in args.groups:
            GroupName = ensureDomain(g)

            Group = gsGroupGet(service,GroupName)
            if (Group):
                Groups += Group
            else:
                print("{}: No such group '{}'".format(CmdName,g))
    else:
        Groups = gsGroupGet(service, groupKey=None)

    Output = []
    for g in Groups:
        group = {}
        group[g['name']] = {
            'Gid': getGroupGid(g),
            'Members': sorted(set(list(map(lambda x: x['email'], gsGetGroupMembers(service, groupKey=g['email'], expand=True)))))
        }

        Output.append(group)
        
    if (args.json):
        print(json.dumps(Groups, indent=2))

    elif (args.cloud_config):
        NewOutput = list(map(lambda x: dict(x), pyjq.all(r'.[]| (keys)[0] as $GroupName | {"\($GroupName)": .[].Members }', Output)))
        print(yaml.dump({"groups": NewOutput}))

    else: # etc defaults
        for l in pyjq.all(r'.[] | (keys)[0] as $GroupName | .[] | .Gid as $Gid | (.Members | @csv | sub("\"";"";"g")) as $Members | "\($GroupName):x:\($Gid):\($Members)"', Output):
            print(l)

def stripGidFromDescription(d):
    return(re.sub('\{\s*gid:\s+\d+\s*\}','',d))

def insertGidInDescription(d,gid):
    return(re.sub(' *$', ' {gid: %s}' % (gid),d))

def gsUserGet(service, userKey=None):

    Users = []
    page_token = None

    while True:
        try:
            if (userKey):
                results = service.users().get(userKey=userKey).execute()
                users = [ results ]

            else:
                results = service.users().list(maxResults=MAXRESULTS, domain=DOMAIN, pageToken=page_token).execute()
                users = results.get('users')

            for u in users:
                Users.append(u)
    
            page_token = results.get('nextPageToken')
            if (not page_token):
                break

        except errors.HttpError as error:
            print('An error occurred: %s' % (error))
            break

    return(Users)

#
# gs-userget [-c|e|j][[user1]...]
#
def userGet():
    parser = argparse.ArgumentParser(description='List GS Users')

    user = parser.add_mutually_exclusive_group()

    user.add_argument('-c', '--cloud-config', action='store_true', help='print /etc/group format')
    user.add_argument('-e', '--etc', action='store_true', help='print /etc/group format')
    user.add_argument('-j', '--json', action='store_true', help='print json')

    parser.add_argument('users', nargs='*', help='users to get, if none specified, get all users')

    args = parser.parse_args()

    service = get_directory_service()

    Users = []

    if (args.users):
        for u in args.users:
            UserName = ensureDomain(u)

            User = gsUserGet(service,UserName)
            if (User):
                Users.append(User)
            else:
                print("{}: No such User '{}'".format(CmdName,u))
    else:
        Users = gsUserGet(service, userKey=None)

    if(args.json):
        print(json.dumps(Users, indent=2))
    elif(args.cloud_config):
        print(yaml.dump(Users, indent=2))


def main():
    if (CmdName == 'gs-groupget'):
        groupGet()
    elif (CmdName == 'gs-groupadd'):
        GroupAdd()
    elif (CmdName == 'gs-groupdel'):
        GroupDel()
    elif (CmdName == 'gs-groupmod'):
        GroupMod()
    elif (CmdName == 'gs-userget'):
        userGet()
    

if __name__ == '__main__':
    main()


