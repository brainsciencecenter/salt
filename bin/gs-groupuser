#!/usr/bin/python3

import pickle
import argparse
import pyjq
import json
import os
import re
import sys
import time
import yaml
import googleapiclient.discovery

from xkcdpass import xkcd_password as xp

from apiclient import errors
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request

import pprint
SCOPES = ['https://www.googleapis.com/auth/admin.directory.user',
          'https://www.googleapis.com/auth/admin.directory.group',
          'https://www.googleapis.com/auth/admin.directory.members']

CUSTOMER_ID = "C04bow9da"
DOMAIN = "pennbrain.upenn.edu"
MAXRESULTS = 2
CmdName = os.path.basename(sys.argv[0])

MinServiceId = 1100
MaxServiceId = 2000
MinCollectiveId = 2100
MaxCollectiveId = 3000
MinUserId = 3001

debug=False

def get_credentials():

    creds = None
    # The file token.pickle stores the user's access and refresh tokens, and is
    # created automatically when the authorization flow completes for the first
    # time.
    if os.path.exists('token.pickle'):
        with open('token.pickle', 'rb') as token:
            creds = pickle.load(token)
    # If there are no (valid) credentials available, let the user log in.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                '/home/holder/.config/gcloud/credentials.json', SCOPES)
            creds = flow.run_local_server(port=0)
        # Save the credentials for the next run
        with open('token.pickle', 'wb') as token:
            pickle.dump(creds, token)

    return creds


def get_directory_service():

    creds = get_credentials()
    service = googleapiclient.discovery.build('admin', 'directory_v1', credentials=creds)

    return service

# gs<function> interact with g-suite/cloud-identity
# <function> do stuff with existing objects/variables

def getGroupGid(Group):
    description = ""

    if ('description' in Group.keys()):
        description = Group['description']

    m = re.search(r'^.*\{\s*gid:\s+(?P<gid>\d+)\s*\}', description)
    if (m):
        gid = m.group('gid')
    else:
        gid = ""

    return(gid)

def getGroupMembers(service, Group, expand=False):
    Members = []

    if ('members' in Group.keys()):
        for m in Group['members']:
            if (m['type'] == "GROUP"):
                Members += list(map(lambda x: x['email'], gsGetGroupMembers(service, groupKey=m['email'])))
            else:
                Members += [ m['email'] ]

    return(','.join(sorted(set(Members))))

def gsGetGroupMembers(service, groupKey=None, expand=False):
    Members = []
    page_token = None

    while True:
        try:
            results = service.members().list(groupKey=groupKey, pageToken=page_token).execute()
            
            members = results.get('members')
            if (members):
                for m in members:
                    if (m['type'] == "GROUP"):
                        ExpandedMembers = gsGetGroupMembers(service, groupKey=m['email'], expand=True)
                        Members += ExpandedMembers
                    else:
                        Members.append(m)

            page_token = results.get('nextPageToken')
            if (not page_token):
                break

        except errors.HttpError as error:
            print('An error occurred: %s' % (error))
            break

    return(Members)

def gsGetMembersGroups(service, User):
    results = client.groups().list(userKey=user,pageToken=None).execute()

def gsGroupGet(service, groupKey=None):

    Groups = []
    page_token = None
    while True:
        try:
            if (groupKey):
                results = service.groups().get(groupKey=groupKey).execute()
                Groups += [ results ]
            else:
                results = service.groups().list(maxResults=MAXRESULTS, domain=DOMAIN, pageToken=page_token).execute()
                Groups += results.get('groups')

            page_token = results.get('nextPageToken')
            if (not page_token):
                break

        except errors.HttpError as error:
            print('{} : gsGroupGet An error occurred: %s'.format(CmdName, error), file=sys.stderr)
            break

    return(Groups)

def ensureDomain(name):
    if (re.search('@', name)):
        n = name
    else:
        n = name + '@{}'.format(DOMAIN)

    return(n)
    
def stripDomain(name):
    return(re.sub('@.*$','',name))
    
def gsAddUsersToGroup(service, groupKey=None, Users=None):

    if (groupKey and Users):
        for user in Users:
            results = service.members().insert(groupKey=groupKey, body={ "email": user }).execute()

def gsDeleteUsersFromGroup(service, groupKey=None, Users=None):

    if (groupKey and Users): 
        for user in Users:
            results = service.members().delete(groupKey=groupKey, memberKey=user).execute()

def gsGetGroupGids(service):

    Groups = []
    page_token = None
    while True:
        try:
            results = service.groups().list(maxResults=2, domain="pennbrain.upenn.edu", pageToken=page_token).execute()
            groups = results.get('groups')
            for g in groups:
                Groups.append(g)

            page_token = results.get('nextPageToken')
            if (not page_token):
                break

        except errors.HttpError as error:
            print('An error occurred: %s' % (error))
            break

    Gids = json.dumps(pyjq.all('.[].description | sub("^.*(?<gid>{gid: [0-9]+}).*$"; "\(.gid)") | sub("gid"; "gid") ', Groups), indent=2)
    Gids = json.loads(re.sub('gid:', '"gid":', re.sub('"', '', Gids)))

    return(sorted(pyjq.all('.[].gid', Gids)))

def isCollectiveId(id):
    return(id >= MinCollectiveId and id <= MaxCollectiveId)

def isServiceId(id):
    return(id >= MinServiceId and id <= MaxServiceId)

def isUserId(id):
    return(id >= MinUserId)

#
# gs-groupadd [-d description][-g gid][-C|r|U][-u user1[[,user2]...] group [group...]
#
def groupAdd():
    parser = argparse.ArgumentParser(description='Create GS groups')
    parser.add_argument('-g', '--gid', type=int, help='posix group id. Defaults to next available id')
    parser.add_argument('-u', '--users', type=str, help='comma separated list of existing users to add to group(s)')
    parser.add_argument('groups', nargs='+', help='groups to get, if none specified, get all groups')

    setop = parser.add_mutually_exclusive_group()
    setop.add_argument('-U', '--collective', action='store_true', help='collective group')
    setop.add_argument('-r', '--service', action='store_true', help='service group for programs/applications')
    setop.add_argument('-U', '--User', action='store_true', help='user default group')
    args = parser.parse_args()

    service = get_directory_service()

    Users = []
    if (args.users):
        Users = list(map(ensureDomain, sorted(args.users.split(','))))

    t = '-c'
    NewGid = None
    for group in args.groups:
        if (args.gid):
            if (NewGid):
                NewGid += 1
            else:
                NewGid = args.gid

            if (isCollectiveId(NewGid)):
                t = '-C'
            elif(isServiceId(NewGid)):
                t = '-r'
            elif(isUserId(NewGid)):
                t = '-U'
            else:
                print("{} : Invalid Gid '{}'".format(CmdName, NewGid), file=sys.stderr)
                sys.exit(1)

        else:
            Gids = gsGetGroupGids(service)

            if (args.collective):
                t = '-C'
                Gid = list(filter(isCollectiveId, Gids))
                if (not Gid):
                    Gid = [ MaxCollectiveGid ]

                NewGid = Gid[0] - 1
            elif (args.service):
                t = '-r'
                Gid = list(filter(isServiceId, Gids))
                if (not Gid):
                    Gid = [ MinServiceGid ]

                NewGid = Gid[0] + 1
            elif (args.User):
                t = '-U'
                Gid = list(filter(isUserId, Gids))
                if (not Gid):
                    Gid = [ MinUserGid ]

                NewGid = Gid[-1] + 1
            else:
                t = '-C'
                Gid = list(filter(isCollectiveId, Gids))
                if (not Gid):
                    Gid = [ MaxCollectiveGid ]

                NewGid = Gid[0] - 1

        g = ensureDomain(group)
        # Create the group.  Creation may fail, group may already exist
        # check gid to ensure no repeats
        # 
        # Add the users.  Users might not all exist
        if (debug):
            print("gsGroupAdd {} -gid {} -u {} {}".format(t,NewGid,','.join(Users), g))
        if (gsCreateGroup(service, g, gid=NewGid) and Users):
                gsAddUsersToGroup(service,groupKey=g, Users=Users)

def gsCreateGroup(service, group, gid=None):
    try:
        results = service.groups().insert(body={ 'name': group, 'email': group, 'description': '{gid: %d}' % (gid)}).execute()
        return(True)
    except errors.HttpError as error:
        print('{}: creating group {} : An error occurred: {}'.format(CmdName, group, error), file=sys.stderr)
        return(False)

def gsDeleteGroup(service, groupKey=None):
    try:
        results = service.groups().delete(groupKey=groupKey).execute()
        return(True)
    except errors.HttpError as error:
        print('{}: creating group {} : An error occurred: {}'.format(CmdName, group, error), file=sys.stderr)
        return(False)

def gsUpdateGroup(service, groupKey=None, body=None):
    try:
        results = service.groups().update(groupKey=groupKey, body=body).execute()
        return(True)
    except errors.HttpError as error:
        print('{}: updating group {} : An error occurred: {}'.format(CmdName, group, error), file=sys.stderr)
        return(False)
    
#
# gs-groupdel group1 [[group2]...]
#
def GroupDel():
    parser = argparse.ArgumentParser(description='Delete GS groups')

    parser.add_argument('groups', nargs='+', help='groups to delete')

    args = parser.parse_args()

    service = get_directory_service()

    for group in args.groups:
        g = ensureDomain(group)
        # Delete the group.  Group may not exist.  Deletion may fail
        gsDeleteGroup(service, groupKey=g)


#
# gs-groupmod [-d description][-g gid][-n name][[-a|r|s] -u user1[[,user2]...] group1 [[group2]...]
#
def GroupMod():
    parser = argparse.ArgumentParser(description='Modify GS groups')
    parser.add_argument('-d', '--description', type=str, help='new description.  Gid will be inserted, if not supplied')
    parser.add_argument('-g', '--gid', type=int, help='posix group id. Defaults to next available id')
    parser.add_argument('-n', '--name', type=str, help='new group name')
    
    parser.add_argument('-u', '--userlist', type=str, help='comma separated list of existing users to add to group(s)')
    parser.add_argument('groups', nargs='+', help='groups to add specified users to')

    setop = parser.add_mutually_exclusive_group()
    setop.add_argument('-a', '--append', action='store_true', help='append users')
    setop.add_argument('-r', '--remove', action='store_true', help='remove users')
    setop.add_argument('-s', '--set', action='store_true', help='set users')

    args = parser.parse_args()

    service = get_directory_service()

    UserList = []

    if(args.userlist):
        UserList = set(map(ensureDomain,re.split(',',args.userlist)))

    for group in args.groups:
        g = ensureDomain(group)
        # Create the group.  Creation may fail
        # Add the users.  Users might not all exist
        Group = gsGroupGet(service, g)
        print("g = ",g)
        if (Group):
            Group=Group[0]
        else:
            next

        GroupBody = { 
            'email': Group['email'], 
            'description': stripGidFromDescription(Group['description']), 
            'name': Group['name'], 
            'gid': getGroupGid(Group)
        }

        UpdateGroup = False

        if (args.description):
            GroupBody['description'] = args.description
            UpdateGroup = True

        # *** should make sure the gid isn't already in use...
        if (args.gid):
            GroupBody['gid'] = args.gid
            UpdateGroup = True

        if (args.name):
            GroupBody['name'] = args.name
            UpdateGroup = True

        print("GroupBody = ", GroupBody)

        if (UpdateGroup):
            GroupBody['description'] = insertGidInDescription(GroupBody['description'], GroupBody['gid'])
            gsUpdateGroup(service, groupKey=g, body=GroupBody)

        if (UserList):
            if (debug):
                print("gsGetGroupMembers = ", set(sorted(list(map(lambda x: x['email'], gsGetGroupMembers(service, groupKey=g, expand=False))))))

            DeleteMembers = []
            AddMembers = []

            CurrentMembers = set(sorted(list(map(lambda x: x['email'], gsGetGroupMembers(service, groupKey=g, expand=False)))))

            if (args.append):
                AddMembers = UserList - CurrentMembers

            elif (args.remove):
                DeleteMembers = CurrentMembers & UserList

            elif (args.set):
                AddMembers = UserList - CurrentMembers
                DeleteMembers = CurrentMembers - UserList - AddMembers

            if (debug):
                print("Delete Members", DeleteMembers)
                print("Add Members", AddMembers)

            if (DeleteMembers):
                gsDeleteUsersFromGroup(service, groupKey=g, Users=DeleteMembers)

            if (AddMembers):
                gsAddUsersToGroup(service, groupKey=g, Users=AddMembers)


#        print("gsGroupAdd -u {} {}".format(','.join(UpdateUsers), g))

#
# gs-groupget [-e|j][-C|r|U][[group1]...]
#
def groupGet():
    parser = argparse.ArgumentParser(description='List GS groups')

    group = parser.add_mutually_exclusive_group()
    group.add_argument('-j', '--json', action='store_true', help='print json')
    group.add_argument('-e', '--etc', action='store_true', help='print /etc/group format')
    group.add_argument('-c', '--cloud-config', action='store_true', help='print /etc/group format')

    parser.add_argument('groups', nargs='*', help='groups to get, if none specified, get all groups')

    args = parser.parse_args()

    service = get_directory_service()

    Groups = []

    if (args.groups):
        for g in args.groups:
            GroupName = ensureDomain(g)

            Group = gsGroupGet(service,GroupName)
            if (Group):
                Groups += Group
            else:
                print("{}: No such group '{}'".format(CmdName,g))
    else:
        Groups = gsGroupGet(service, groupKey=None)

    Output = []
    for g in Groups:
        group = {}
        group[g['name']] = {
            'Gid': getGroupGid(g),
            'Members': sorted(set(list(map(lambda x: x['email'], gsGetGroupMembers(service, groupKey=g['email'], expand=True)))))
        }

        Output.append(group)
        
    if (args.json):
        print(json.dumps(Groups, indent=2))

    elif (args.cloud_config):
        NewOutput = list(map(lambda x: dict(x), pyjq.all(r'.[]| (keys)[0] as $GroupName | {"\($GroupName)": .[].Members }', Output)))
        print(yaml.dump({"groups": NewOutput}))

    else: # etc defaults
        for l in pyjq.all(r'.[] | (keys)[0] as $GroupName | .[] | .Gid as $Gid | (.Members | @csv | sub("\"";"";"g")) as $Members | "\($GroupName):x:\($Gid):\($Members)"', Output):
            print(l)

def stripGidFromDescription(d):
    return(re.sub('\{\s*gid:\s+\d+\s*\}','',d))

def insertGidInDescription(d,gid):
    return(re.sub(' *$', ' {gid: %s}' % (gid),d))

def gsUserGet(service, userKey=None):

    Users = []
    page_token = None

    while True:
        try:
            if (userKey):
                results = service.users().get(userKey=userKey).execute()
                Users.append(results)
            else:
                results = service.users().list(maxResults=MAXRESULTS, domain=DOMAIN, pageToken=page_token).execute()
                Users += results.get('users')

            page_token = results.get('nextPageToken')
            if (not page_token):
                break

        except errors.HttpError as error:
            print('An error occurred: %s' % (error))
            break

    return(Users)

#
# *** need to add filter of user type service collective, user
# gs-userget [-c|e|j][-C|r|U][[user1]...]
#
def userGet():
    parser = argparse.ArgumentParser(description='List GS Users')

    user = parser.add_mutually_exclusive_group()

    user.add_argument('-c', '--cloud-config', action='store_true', help='print /etc/group format')
    user.add_argument('-e', '--etc', action='store_true', help='print /etc/group format')
    user.add_argument('-j', '--json', action='store_true', help='print json')

    parser.add_argument('users', nargs='*', help='users to get, if none specified, get all users')

    args = parser.parse_args()

    service = get_directory_service()

    Users = []

    if (args.users):
        for u in args.users:
            UserName = ensureDomain(u)

            User = gsUserGet(service,UserName)
            if (User):
                Users += User
            else:
                print("{}: No such User '{}'".format(CmdName,u))
    else:
        Users = gsUserGet(service, userKey=None)

    if(args.json):
        print(json.dumps(Users, indent=2))
    elif(args.cloud_config):
        print(yaml.dump(Users, indent=2))
    else:
        for u in Users:
            # *** What to do about google service accounts?
            if ('posixAccounts' in u.keys()):
                print("{}:{}:{}:{}:{},,,:{}:{}".format(u['posixAccounts'][0]['username'],
                                                   'x',
                                                   u['posixAccounts'][0]['uid'],
                                                   u['posixAccounts'][0]['gid'],
                                                   u['name']['fullName'],
                                                   u['posixAccounts'][0]['homeDirectory'],
                                                   u['posixAccounts'][0]['shell']))

def gsGetUserUids(service):

    Users = []
    page_token = None
    while True:
        try:
            results = service.users().list(maxResults=MAXRESULTS, domain=DOMAIN, pageToken=page_token).execute()
            users = results.get('users')
            for u in users:
                Users.append(u)

            page_token = results.get('nextPageToken')
            if (not page_token):
                break

        except errors.HttpError as error:
            print('An error occurred: %s' % (error))
            break

    Uids = pyjq.all('.[]|(.posixAccounts[].uid)?', Users)
    
    return(sorted(list(set(map(int,Uids)))))

def gsUserMod(service, userKey=None, GivenName=None, FamilyName=None, gecos=None, homedir=None, uid=None, gid=None, shell=None,  username=None, sshkeys=[], secondaryEMails=[], reset_password=False, password=None, verbose=False, noop=False):

    Update = False

    Body = gsUserGet(service,userKey=userKey)[0]
    if ('posixAccounts' in Body.keys()):
        posixAccount = Body['posixAccounts'][0]
        print("posixAccount type = ", type(posixAccount))
    else:
        posixAccount = {
            "systemId": "",
            "primary": True,
            "operatingSystemType": "unspecified"
        }


    """
    Body['name'] = {}

    if (GivenName):
        Body['Name']['GivenName'] = GivenName
        Update = True
    
    if (FamilyName):
        Body['Name']['FamilyName'] = FamilyName
        Update = True
    """
    
    if (gecos):
        posixAccount['gecos'] = gecos

    if (homedir):
        posixAccount['homeDirectory'] = homedir
        Update = True
    
    if (uid):
        posixAccount['uid'] = str(uid)
        Update = True
    
    if (gid):
        posixAccount['gid'] = str(gid)
        Update = True

    if (shell):
        posixAccount['shell'] = shell
        Update = True
    
    if (username):
        posixAccount['username'] = username
        Update = True
    
    if (sshkeys):
        Body['sshPublicKeys'] = sshkeys
        Update = True
    
    if (sshkeys):
        Body['sshPublicKeys'] = sshkeys
        Update = True
    
    if (secondaryEMails):
        Body['emails'] = emails
        Update = True

    if (reset_password):
        Body['changePasswordAtNextLogin'] = reset_password
        Update = True

    if (password):
        Body['password'] = password
        Update = True

    if (verbose):
        print("gsUserMod ", locals())

    Body['posixAccounts'] = [ posixAccount ]
    try:
        results = service.users().update(userKey=userKey, body=Body).execute()
        print("gsUserMod UpdateBody results", json.dumps(results, indent=2))
    except errors.HttpError as error:
        print('An error updating the body for {} occurred: {}'.format(userKey,error.content), file=sys.stderr)            
        return(False)

    return(results)


#
# Required to create a new account
# + givenName
# + familyName
# + primaryEmail
# + password
def gsUserAdd(service, primaryEmail=None, username=None, uid=None, gid=None, homedir=None, shell=None, sshkeys=[], secondaryEMails=[], reset_password=False, password=None, GivenName=None, FamilyName=None, verbose=False, noop=False):

    Body = {}
    Body['name'] = {}

    if (verbose):
        print("gsUserAdd")
        
    if (primaryEmail):
        Body['primaryEmail'] = primaryEmail
    
    if (GivenName):
        Body['name']['givenName'] = GivenName
    
    if (FamilyName):
        Body['name']['familyName'] = FamilyName
    
    if (sshkeys):
        Body['sshPublicKeys'] = sshkeys
        UpdateBody = True
    
    if (secondaryEMails):
        Body['emails'] = list(map(lambda x: {'address': x, 'type': 'work'}, secondaryEMails))
        Body['recoveryEmail'] = secondaryEMails[0]
        
    Body['changePasswordAtnextLogin'] = reset_password

    if (password):
        Body['password'] = password

    if (verbose or noop):
        print(json.dumps(Body, indent=2))

    try:
        results = service.users().insert(body=Body).execute()
        if (results):
            # only need to update posixAccount info, cause you can't seem to add it with 
            # the rest of the body
            try:
                if (verbose):
                    print("Calling gsUserMod", username)
                time.sleep(1)
                results2 = gsUserMod(service, userKey=primaryEmail, homedir=homedir, uid=uid, gid=gid, shell=shell, username=username, verbose=verbose, noop=verbose)
                print("Return from gsUserMod")
            except errors.HttpError as error:
                print('An error updating the posixAccounts occurred: %s' % (error), file=sys.stderr)            
                return(False)

    except errors.HttpError as error:
        print('An error adding user {} occurred: {}'.format(username,error), file=sys.stderr)
    
    
#
# *** set password, require new password on login, 2ndary email address
# gs-user_add [-c comment][-d homedir][-G group1[[group2]...][-M email1[[,email2]..]][-p password] [-C|r|U][-S shell][-s ssh-key][-u uid] user1 [[user2]...]
#
def userAdd():
    parser = argparse.ArgumentParser(description='Create GS users')
    parser.add_argument('-c', '--comment', type=str, help='User name')
    parser.add_argument('-d', '--homedir', type=str, help='users home directory path')
    parser.add_argument('-G', '--groups', type=str, help='comma separated list of groups to add user to')
    idspace = parser.add_mutually_exclusive_group()
    idspace.add_argument('-C', '--collective', action='store_true', help='Collective IDs')
    idspace.add_argument('-r', '--service', action='store_true', help='Service IDs')
    idspace.add_argument('-U', '--user', action='store_true', help='Users IDs')

    parser.add_argument('-M', '--emails', type=str, required=True, help='comma separated emails to associate with user')
    parser.add_argument('-p', '--password', type=str, help='Users unencrypted password')
    parser.add_argument('-R', '--reset-password', action='store_true', help='require password reset on first login')
    parser.add_argument('-n', '--noop', action='store_true', help='dont do anything, just show what would be done')
    parser.add_argument('-v', '--verbose', action='store_true', help='show whats being done')
    parser.add_argument('-S', '--shell', type=str, help='login shell')
    parser.add_argument('-s', '--ssh-keys', type=str, help='comma separated ssh public keys, or files containing key')
    parser.add_argument('-u', '--uid', type=int, help='posix user id. Defaults to next available id')
    parser.add_argument('users', nargs='+', help='usernames to create')

    args = parser.parse_args()

    service = get_directory_service()

    Comment = ""
    HomeDir = ""
    GivenName = ""
    FamilyName = ""
    Groups = []
    EMails = []
    Password = None
    RequirePasswordReset = False
    t = "-U"
    Shell = '/bin/bash'       # *** should probably readd form cluster-config.yaml
    SshKeys = []
    NewUid = None

    noop = args.noop
    verbose = args.verbose

    for user in args.users:
        u = ensureDomain(user)
        UserName = stripDomain(user)

        if (args.comment):
            Comment = args.comment
            NameField = re.sub(',.*$','',Comment)
            if (re.search(' ', NameField)):
                GivenName = NameField.split(' ')[0]
                FamilyName = NameField.split(' ')[-1]
        else:
            GivenName = UserName
            FamilyName = UserName 

        if (args.homedir):
            HomeDir = args.homedir
        else:
            HomeDir = "/home/{}".format(UserName)

        if (args.groups):
            Groups = sorted(list(set(args.groups.split(','))))

        # *** will have to deal with password hashing at some point
        if (args.password):
            try:
                with open(args.password) as x: Password = x.read().rstrip()
            except (OSError, IOError, FileNotFoundError) as e:
                Password = args.password
        else:
            # create a wordlist from the default wordfile
            # use words between 5 and 8 letters long
            wordfile = xp.locate_wordfile()
            mywords = xp.generate_wordlist(wordfile=wordfile, min_length=5, max_length=8)
            mywords = [x.capitalize() for x in mywords]
            Password = xp.generate_xkcdpassword(mywords, numwords=4, delimiter='')

        RequirePasswordReset = args.reset_password
            
        if (args.service):
            t = '-r'

        if (args.collective):
            t = '-C'

        if (args.user):
            t = '-U'

        if (args.ssh_keys):
            try:
                with open(args.ssh_keys) as x: [ SshKeys ] = x.read().rstrip()
            except (OSError, IOError, FileNotFoundError) as e:
                SshKeys = args.ssh_key.split(',')

        if (args.shell):
            Shell = args.shell

        if (args.uid):
            if (NewUid):
                NewUid += 1
            else:
                NewUid = int(args.uid)

        else:
            Uids = gsGetUserUids(service)
            #
            # *** Can't create a collective user, only collective groups
            #     which are reflected in the user space
            # *** Might be able to use the custom schema to add collective groups
            ServiceUids = list(filter(isServiceId, Uids))

            if (args.service):
                if (ServiceUids):
                    NewUid = ServiceUids[-1] + 1
                else:
                    if (NewUid):
                        NewUid += 1
                    else:
                        NewUid = MinServiceId 
            else:
                NewUid = int(Uids[-1]) + 1

            # *** Figure out next service uid or next regular user id

        if (SshKeys):
            Body['sshPublicKeys'] = list(map(lambda x: {'key': x, 'expirationTimeUsec': 0}, SshKeys))

        if (args.emails):
            EMails = sorted(list(set(args.emails.split(','))))

        if (verbose):
            print("userAdd -c {} -d {} -G {} {} -M {} -p {} -R {} -S {} -s {} -u {} {} {}".format(Comment,HomeDir,','.join(Groups),t,','.join(EMails), Password, RequirePasswordReset,Shell,SshKeys,NewUid,UserName, u))

        Res = True
        if (not noop):
            Res = gsUserAdd(service, primaryEmail=u, username=UserName, uid=NewUid, gid=NewUid, homedir=HomeDir, shell=Shell, sshkeys=SshKeys, secondaryEMails=EMails, reset_password=RequirePasswordReset, password=Password, GivenName=GivenName, FamilyName=FamilyName, noop=noop, verbose=verbose)

        if (Res):
            print("Res = ",json.dumps(Res,indent=2))

            if (Groups):
                for g in Groups:
                    gsAddUserToGroup(service,groupKey=g, Users=[u])
        else:
            print("UserAdd Failed", file=sys.stderr)


def userMod():
    parser = argparse.ArgumentParser(description='Modify GS users')
    parser.add_argument('-d', '--homedir', type=str, help='users home directory path')
    parser.add_argument('-G', '--groups', type=str, help='comma separated list of groups to add user to')
    parser.add_argument('-g', '--gid', type=int, help='posix group id.lable id')
    parser.add_argument('-M', '--emails', type=str, help='comma separated emails to associate with user, resets all emails')
    parser.add_argument('-p', '--password', type=str, help='Users unencrypted password')
    parser.add_argument('-R', '--reset-password', action='store_true', help='require password reset on first login')
    parser.add_argument('-n', '--noop', action='store_true', help='dont do anything, just show what would be done')
    parser.add_argument('-v', '--verbose', action='store_true', help='show whats being done')
    parser.add_argument('-S', '--shell', type=str, help='login shell')
    parser.add_argument('-s', '--ssh-keys', type=str, help='comma separated ssh public keys, or files containing key')
    parser.add_argument('-u', '--uid', type=int, help='posix user id. Defaults to next available id')
    parser.add_argument('users', nargs='+', help='usernames to create')

    args = parser.parse_args()

    service = get_directory_service()

    HomeDir = None
    GivenName = None
    FamilyName = None
    Groups = []
    EMails = []
    Password = None
    RequirePasswordReset = False
    t = "-U"
    SshKeys = []
    NewUid = None
    NewGid = None
    Shell = None

    noop = args.noop
    verbose = args.verbose

    for user in args.users:
        u = ensureDomain(user)
        UserName = stripDomain(user)

        if (args.homedir):
            HomeDir = args.homedir

        if (args.groups):
            Groups = sorted(list(set(args.groups.split(','))))

        # *** will have to deal with password hashing at some point
        if (args.password):
            try:
                with open(args.password) as x: Password = x.read().rstrip()
            except (OSError, IOError, FileNotFoundError) as e:
                Password = args.password
        else:
            # create a wordlist from the default wordfile
            # use words between 5 and 8 letters long
            wordfile = xp.locate_wordfile()
            mywords = xp.generate_wordlist(wordfile=wordfile, min_length=5, max_length=8)
            mywords = [x.capitalize() for x in mywords]
            Password = xp.generate_xkcdpassword(mywords, numwords=4, delimiter='')

        RequirePasswordReset = args.reset_password
            
        if (args.ssh_keys):
            try:
                with open(args.ssh_keys) as x: [ SshKeys ] = x.read().rstrip()
            except (OSError, IOError, FileNotFoundError) as e:
                SshKeys = args.ssh_key.split(',')

        if (args.shell):
            Shell = args.shell

        if (args.uid):
            NewUid = int(args.uid)

        if (args.gid):
            NewGid = int(args.gid)

        if (SshKeys):
            Body['sshPublicKeys'] = list(map(lambda x: {'key': x, 'expirationTimeUsec': 0}, SshKeys))

        if (args.emails):
            EMails = sorted(list(set(args.emails.split(','))))

        if (verbose):
            print("userMod -d {} -G {} {} -M {} -p {} -R {} -S {} -s {} -u {} {} {}".format(HomeDir,','.join(Groups),t,','.join(EMails), Password, RequirePasswordReset,Shell,SshKeys,NewUid,UserName, u))
        try:
            results2 = gsUserMod(service, userKey=u, homedir=HomeDir, uid=NewUid, gid=NewGid, shell=Shell, username=UserName, verbose=verbose, noop=verbose)
            print("results2", json.dumps(results2, indent=2))
        except errors.HttpError as error:
            print('An error updating user {} occurred: {}'.format(primaryEmail,error), file=sys.stderr)

def gsUserDel(service, userKey=None):
    try:
        results = service.users().delete(userKey=userKey).execute()
        return(True)
    except errors.HttpError as error:
        print('{}: deleting user {} : An error occurred: {}'.format(CmdName, userKey, error), file=sys.stderr)
        return(False)

#
# gs-userdel user1 [[user2]...]
# 
def userDel():

    parser = argparse.ArgumentParser(description='Delete GS Users')

    parser.add_argument('users', nargs='+', help='users to delete')

    args = parser.parse_args()

    service = get_directory_service()

    for user in args.users:
        u = ensureDomain(user)
        # Delete the user. user may not exist.  Deletion may fail
        gsUserDel(service, userKey=u)

    
def main():
    if (CmdName == 'gs-groupget'):
        groupGet()
    elif (CmdName == 'gs-groupadd'):
        groupAdd()
    elif (CmdName == 'gs-groupdel'):
        GroupDel()
    elif (CmdName == 'gs-groupmod'):
        GroupMod()
    elif (CmdName == 'gs-userget'):
        userGet()
    elif (CmdName == 'gs-useradd'):
        userAdd()
    elif (CmdName == 'gs-userdel'):
        userDel()
    elif (CmdName == 'gs-usermod'):
        userMod()
    elif (CmdName == 'gs-userid'):
        userId()
    elif (CmdName == 'gs-dump'):
        gsDump()

if __name__ == '__main__':
    main()


