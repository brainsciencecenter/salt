#!/usr/bin/python3

#
# Group IDs
# User default group ids start at 3001 and go up
# Group ids for pennbrain.upenn.edu start at 3000 and go down
# Service account user and group ids start at 1100 and go up
# Not expecting more than 100 groups so 2900 to 3000 should be fine
# Not expecting more than 100 service accounts so 1100 to 1200 should be fine
#
# https://google-api-client-libraries.appspot.com/documentation/admin/directory_v1/python/latest/index.html

# https://googleapis.github.io/google-api-python-client/docs/epy/googleapiclient.discovery-module.html
# https://developers.google.com/admin-sdk/directory/v1/quickstart/python
# https://developers.google.com/admin-sdk/directory/v1/reference/users
# https://stackoverflow.com/questions/24541067/google-directory-api-groups
#

import pickle
import argparse
import pyjq
import json
import os
import re
import sys
import time
import googleapiclient.discovery
from apiclient import errors
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request

import pprint
SCOPES = ['https://www.googleapis.com/auth/admin.directory.user',
          'https://www.googleapis.com/auth/admin.directory.group',
          'https://www.googleapis.com/auth/admin.directory.members']

CUSTOMER_ID = "C04bow9da"
DOMAIN = "pennbrain.upenn.edu"
MAXRESULTS = 2
#CUSTOMER_ID = "pennbrain.upenn.edu"
def get_credentials():

    creds = None
    # The file token.pickle stores the user's access and refresh tokens, and is
    # created automatically when the authorization flow completes for the first
    # time.
    if os.path.exists('token.pickle'):
        with open('token.pickle', 'rb') as token:
            creds = pickle.load(token)
    # If there are no (valid) credentials available, let the user log in.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                '/home/holder/.config/gcloud/credentials.json', SCOPES)
            creds = flow.run_local_server(port=0)
        # Save the credentials for the next run
        with open('token.pickle', 'wb') as token:
            pickle.dump(creds, token)

    return creds


def get_directory_service():

    creds = get_credentials()
    service = googleapiclient.discovery.build('admin', 'directory_v1', credentials=creds)

    return service

def update_user_posix_credentials(user_email, home_dir, username, shell, uid, gid, key):

    user = service.users().get(userKey=user_email).execute()

    # Verify that the user has a posixAccount

    if 'posixAccounts' in user.keys():
        posix_account = user['posixAccounts'][0]
        print('Existing POSIX account info:')
        print(posix_account)
        print(json.dumps(user, indent=2))
    else :
        print( 'No POSIX account information found. Creating POSIX account metadata' )
        pprint.pprint( user )
        posix_account = {}

    # Update credentials
    posix_modified = False

    if home_dir:
        posix_account['homeDirectory'] = home_dir
        posix_modified = True

    if username:
        posix_account['username'] = username
        posix_modified = True

    if shell:
        posix_account['shell'] = shell
        posix_modified = True

    if uid:
        posix_account['uid'] = str(uid)
        posix_modified = True

    if gid:
        posix_account['gid'] = str(gid)
        posix_modified = True


    pprint.pprint( posix_account )
    if posix_modified:

        posix_account['shell'] = '/bin/bash'
        update_command = service.users().update(userKey=user_email,
                                                body={'posixAccounts': [posix_account]})
        update_command.execute()


        print('POSIX account info updated; changes may take a few seconds to propagate. '
              'Check `gcloud beta compute os-login describe-profile` for changes')

    if key:
        if 'sshPublicKeys' in user.keys():
            public_keys = user['sshPublicKeys'][0]
        else:
            public_keys = {}

        public_keys['key'] = key

        update_command = service.users().update(userKey=user_email,
                                            body={'sshPublicKeys': [public_keys]})
        time.sleep(1)
        update_command.execute()
        print('Public RSA Key info updated; changes may take a few seconds to propagate. '
              'Check `gcloud beta compute os-login describe-profile` for changes')


def getGroup(service, groupKey=None):
    Members = []
    page_token = None
    while True:
        try:
            results = service.members().list(groupKey=groupKey, pageToken=page_token).execute()
            
            members = results.get('members')
            for m in members:
                Members.append(m)

            page_token = results.get('nextPageToken')
            if (not page_token):
                break
        except errors.HttpError as error:
            print('An error occurred: %s' % (error))
            break

    return(Members)

def addUsersToGroup(service, group=None, Users=None):

    if (group and Users):
        for user in Users:
            results = service.members().insert(groupKey=group, body={ "email": user }).execute()
            print(json.dumps(results, indent=2))
            

def deleteUsersFromGroup(service, group=None, Users=None):
    groupKey = 'holder-group@pennbrain.upenn.edu'
    memberEmail = 'gmcfoo@pennbrain.upenn.edu'

    results = service.members().delete(groupKey=groupKey, memberKey=memberEmail).execute()
    print(json.dumps(results, indent=2))

def createGroup(service, group, gid=None):
    results = service.groups().insert(body={ 'name': group, 'email': group, 'description': '{gid: %d}' % (gid)}).execute()
    print(json.dumps(results, indent=2))
    
def deleteGroup(service, group=None):
    results = service.groups().delete(groupKey=group).execute()
    print(json.dumps(results, indent=2))

def getMinGroupGid(service):

    Groups = []
    page_token = None
    while True:
        try:
            results = service.groups().list(maxResults=2, domain="pennbrain.upenn.edu", pageToken=page_token).execute()
            groups = results.get('groups')
            for g in groups:
                Groups.append(g)

            page_token = results.get('nextPageToken')
            if (not page_token):
                break

        except errors.HttpError as error:
            print('An error occurred: %s' % (error))
            break

#    print(json.dumps(sorted(jq('.[].description | sub("^.*(?<gid>{gid: [0-9]+}).*$";"\(.gid)") | sub("gid"; "\"gid\"") | fromjson.gid'), indent=2)))
    Gids = json.dumps(pyjq.all('.[].description | sub("^.*(?<gid>{gid: [0-9]+}).*$"; "\(.gid)") | sub("gid"; "gid") ', Groups), indent=2)
    Gids = json.loads(re.sub('gid:', '"gid":', re.sub('"', '', Gids)))

    return(sorted(pyjq.all('.[].gid', Gids))[0])

def listUsers(service):
    page_token = None
    Users = []

    while True:
        try:
            results = service.users().list(customer=CUSTOMER_ID, maxResults=MAXRESULTS, domain=DOMAIN, pageToken=page_token).execute()
            users = results.get('users')
            for u in users:
                Users.append(u)

            page_token = results.get('nextPageToken')
            if (not page_token):
                break
        except errors.HttpError as error:
            print('An error occurred: %s' % (error))
            break

    print(json.dumps(Users, indent=2))

def addUser(service, username=None, firstname=None, lastname=None, password=None, email=None):
    
    user = {
        "name": {
            "familyName": lastname,
            "givenName": firstname
        },
        "password": password,
        "primaryEmail": username,
        "customerId": CUSTOMER_ID,
        
        "emails": [ 
            { "address": email, 'type': 'work' }
        ],
        "changePasswordAtNextLogin": True
    }

    result = service.users().insert(body=user).execute()
    print(json.dumps(result.get('users')))

def getUser(service, userKey=None):

    results = service.users().get(userKey=userKey).execute()
    print(json.dumps(results, indent=2))

def deleteUser(service, userKey=None):
    
    results = service.users().delete(userKey=userKey).execute()
    print(json.dumps(results, indent=2))


def main():

    parser = argparse.ArgumentParser(description='Utility for modifying POSIX user information')
    parser.add_argument('user_email', nargs='*')
    parser.add_argument('--home_dir', help='new home directory for the user')
    parser.add_argument('--username', help='new username for the user')
    parser.add_argument('--shell', help='new shell for the user')
    parser.add_argument('--uid', choices=range(1001, 65000), metavar='[1001-64999]',
                           type=int, help='new user ID for the user')
    parser.add_argument('--gid', type=int, help='new group ID for the user')
    parser.add_argument('--key', type=str, help='new public RSA key for the user')

    args = parser.parse_args()

    service = get_directory_service()

    getUser(service, "gmcfoo@pennbrain.upenn.edu")
#    deleteUser(service,"gmcfoo2@pennbrain.upenn.edu")    
#    listUsers(service)
#    addUser(service, username="gmcfoo2@pennbrain.upenn.edu", firstname="George", lastname="McFoo2", password="YiddishPurifyStubbedGenetics", email="gaylord.holder@gmail.com")
    
#    print(getMinGroupGid(service))

#    createGroup(service, group="holder-demo-group@pennbrain.upenn.edu", gid=2999)
#    deleteGroup(service, group="holder-demo-group@pennbrain.upenn.edu")
    sys.exit(0)

    Users = []
    Groups = []
    Members = []
    page_token = None


    while True:
        try:
            results = service.groups().list(maxResults=2, domain="pennbrain.upenn.edu", pageToken=page_token).execute()
#            results = service.users().list(customer="C04bow9da", maxResults=2, domain="pennbrain.upenn.edu", pageToken=page_token).execute()
#            users = results.get('users')
#            for u in users:
#                Users.append(u)
            groups = results.get('groups')
            for g in groups:
                g['members'] = getGroup(service,g['email'])
                Groups.append(g)
    
            page_token = results.get('nextPageToken')
            if (not page_token):
                break
        except errors.HttpError as error:
            print('An error occurred: %s' % (error))
            break

#    for g in Groups:
#        print(getGroup(service, groupKey=g["email"]))

    sys.exit(0)
    MaxUID = sorted(jq('[ ..|.uid?|strings]').transform(Users))[-1]
    MaxUserGID = sorted(jq('[ ..|.gid?|strings]').transform(Users))[-1]
    print("MaxUID = ", MaxUID, "MaxGID = ", MaxGID)
    
    sys.exit(0)
    update_user_posix_credentials(**vars(args))

    # update_user_rsa_keys
    

if __name__ == '__main__':
    main()
